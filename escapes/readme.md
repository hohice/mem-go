- 静态分配到栈上，性能一定比动态分配到堆上好。
  1. 垃圾回收（GC）的压力不断增大
  2. 申请、分配、回收内存的系统开销增大（相对于栈）。
  3. 动态分配产生一定量的内存碎片。
- 底层分配到堆，还是栈。实际上对你来说是透明的，不需要过度关心。
- 每个 Go 版本的逃逸分析都会有所不同（会改变，会优化）。
- 直接通过 go build -gcflags '-m -l' 就可以看到逃逸分析的过程和结果。
  1. -m 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是信息量较大，一般用 1 个就可以了。
  2. -l 会禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰。
- go tool compile -S main.go 查看反编译命令
  1.  CALL 指令，执行 runtime.newobject 方法，也就是确实是分配到了堆上。
- 到处都用指针传递并不一定是最好的。

- case-1 指针，非局部指针逃逸
- case-2 局部变量，不逃逸
- case-3 未确定类型，反射导致逃逸